/* _GlobalPrefix_ */
/* _Module_:pz */
try{
/** @suppress {missingRequire} */ goog.module.ModuleManager.getInstance().beforeLoadModuleCode('pz');
var $googDebugFname="googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_types.js";
goog.loadModule("goog.module(\x27gws.images.viewer.pinch.types\x27);\n\nconst Coordinate \x3d goog.require(\x27goog.math.Coordinate\x27);\n\n/**\n * Instantaneous representation of a two-finger pinch gesture.\n * @typedef {{diameter:number, center:!Coordinate,\n *     pt1:!Coordinate, pt2:!Coordinate, timeStamp: number}}\n */\nexports.PinchState;\n\n\n/**\n * Instantaneous representation of a one-finger drag gesture.\n * @typedef {{position:!Coordinate, timeStamp:number}}\n */\nexports.DragState;\n\n\n/**\n * Representation of the transformation applied by pinch and/or drag gestures.\n * @typedef {{scale:number, translation:!Coordinate}}\n */\nexports.PinchTransformation;\n\n\n/**\n * Types of gestures handled by Pinch-to-Zoom.\n * @enum {number}\n */\nexports.Gesture \x3d {\n  NONE: 0,\n  PINCH: 1,\n  DRAG: 2\n};\n\n/**\n * Enum of possible directions of a swipe.\n * @enum {number}\n */\nexports.SwipeDirection \x3d {\n  UNDETERMINED: 0,\n  UP: 1,\n  LEFT: 2,\n  DOWN: 3,\n  RIGHT: 4\n};\n\n//# sourceURL\x3dhttps://qs/googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_types.js\n");

$googDebugFname=undefined;
var $googDebugFname="googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_utils.js";
goog.loadModule("/**\n * @fileoverview Utilities for pinch to zoom feature.\n * @author ejharrington@google.com (Ellery Harrington)\n */\n\ngoog.module(\x27gws.images.viewer.pinch.util\x27);\ngoog.module.declareLegacyNamespace();\n\nconst AnimationTimingParams \x3d goog.require(\x27search.animation.AnimationTimingParams\x27);\nconst Coordinate \x3d goog.require(\x27goog.math.Coordinate\x27);\nconst Disposable \x3d goog.require(\x27goog.Disposable\x27);\nconst EventType \x3d goog.require(\x27goog.events.EventType\x27);\nconst Promise \x3d goog.require(\x27goog.Promise\x27);\nconst events \x3d goog.require(\x27goog.events\x27);\nconst scheduler \x3d goog.require(\x27search.task.scheduler\x27);\nconst style \x3d goog.require(\x27goog.style\x27);\nconst styleTransition \x3d goog.require(\x27goog.style.transition\x27);\nconst vendor \x3d goog.require(\x27goog.dom.vendor\x27);\nconst {PinchTransformation} \x3d goog.require(\x27gws.images.viewer.pinch.types\x27);\n\n/**\n * The delay after a CSS animation is expected to complete to wait before\n * resolving its Promise.\n * @const {number}\n */\nconst TIMEOUT_DELAY \x3d 1000;\n\n\n/**\n * The maximum time that a press can be considered a tap.\n * @const\n */\nconst TIME_TAP_MAX \x3d 150;\n\n/**\n * The maximum time between two taps that can be considered a double-tap.\n * @const\n */\nconst TIME_SPACING_MAX \x3d 175;\n\n/**\n * The maximum distance in pixels from the tap start to tap end to be\n * considered a tap.\n * @const\n */\nconst DISTANCE_TAP_MAX \x3d 15;\n\n/**\n * The maximum distance in pixels from one tap to the next to be considered\n * a double-tap.\n * @const\n */\nconst DISTANCE_BETWEEN_TAPS_MAX \x3d 100;\n\n/**\n * Get the number of active or changed touches for an event.\n * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n * @param {boolean\x3d} opt_changedTouches True to return the number of changed\n *     touches; otherwise return the number of active touches.\n * @return {number} Number of touches.\n */\nfunction eventNumTouches(event, opt_changedTouches) {\n  return opt_changedTouches ? event.getBrowserEvent().changedTouches.length :\n                              event.getBrowserEvent().touches.length;\n}\n\n\n/**\n * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n * @param {number} touchIndex The index in the event\x27s touches array to use.\n * @param {boolean\x3d} opt_changedTouch True to use the event\x27s changed touches;\n *     otherwise use active touches.\n * @return {!Coordinate} The location of the touch.\n */\nfunction eventTouchCoord(event, touchIndex, opt_changedTouch) {\n  const rawEvent \x3d event.getBrowserEvent();\n  const touch \x3d opt_changedTouch ? rawEvent.changedTouches[touchIndex] :\n                                   rawEvent.touches[touchIndex];\n  return Coordinate.difference(\n      new Coordinate(touch.pageX, touch.pageY),\n      style.getViewportPageOffset(goog.global.document));\n}\n\n\n/**\n * Gets the timestamp of a browser event.\n * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n * @return {number} The timestamp of the event.\n */\nfunction eventTimeStamp(event) {\n  return event.getBrowserEvent().timeStamp;\n}\n\n\n/**\n * Determine whether two pinch transformations are equal in both scale and\n * translation.\n * @param {!PinchTransformation} transformation1\n *     A pinch transformation.\n * @param {!PinchTransformation} transformation2\n *     A second pinch transformation.\n * @return {boolean} True if the pinch tranformations are equal.\n */\nfunction pinchTransformationsEqual(transformation1, transformation2) {\n  return transformation1.scale \x3d\x3d transformation1.scale \x26\x26\n      Coordinate.equals(\n          transformation1.translation, transformation2.translation);\n}\n\n\n/**\n * Setup a CSS3 transition animation.  This will not play the animation, but\n * will assign the CSS transition property and listen for the end of the\n * transition.  The animation should be activated in a goog.async.nextTick\n * immediately after calling this function by assigning the properties to\n * animate.  A timeout is initiated, which will take effect 1 second after the\n * animation is expected to complete, in case the animation does not work\n * correctly or the TRANSITIONEND is not fired.\n * This method is provided as an alternative to using the Quantum Motions\n * library, when it is not available but animations should still be present.\n * @param {!Element} element The element to animate.\n * @param {!AnimationTimingParams} animateTimingParams\n * @return {!Promise} Promise to resolve on completion of the transition,\n *     or when the timeout has elapsed.\n */\nfunction setupTransformAnimation(element, animateTimingParams) {\n  const resolver \x3d Promise.withResolver();\n  let listenerKey;\n  let timeoutKey;\n  function cleanup() {\n    scheduler.clearTimeout(timeoutKey);\n    if (listenerKey) {\n      events.unlistenByKey(listenerKey);\n    }\n    styleTransition.removeAll(element);\n    resolver.resolve();\n  }\n  const transformPropertyName \x3d vendor.getVendorPrefix() + \x27-transform\x27;\n  /** @type {styleTransition.Css3Property} */\n  const transition \x3d {\n    property: transformPropertyName,\n    duration: animateTimingParams.duration / 1000,\n    timing: animateTimingParams.easing || \x27ease\x27,\n    delay: animateTimingParams.delay || 0\n  };\n  styleTransition.set(element, transition);\n  listenerKey \x3d events.listen(element, EventType.TRANSITIONEND, cleanup);\n  // Watchdog timer in case TRANSITIONEND is not called.\n  timeoutKey \x3d scheduler.setTimeout(\n      cleanup, animateTimingParams.duration / 1000 + TIMEOUT_DELAY);\n  return resolver.promise;\n}\n\n\n/**\n * Determines whether a series of taps should be treated as a single-tap, a\n * double-tap, or neither.\n */\nclass DoubleTapHelper extends Disposable {\n  /**\n   * @param {function(!events.BrowserEvent, !Coordinate)}\n   *     doubleTapHandler The function to handle a double-tap gesture.\n   * @param {function(!events.BrowserEvent)\x3d} opt_singleTapHandler The\n   *     function to handle a single-tap gesture.\n   */\n  constructor(doubleTapHandler, opt_singleTapHandler) {\n    super();\n\n    /**\n     * Location of the first tap.\n     * @private {?Coordinate}\n     */\n    this.location_ \x3d null;\n\n    /**\n     * Timestamp of the start of the most recent tap.  Updated for both the\n     * first and second clicks.\n     * @private {?number}\n     */\n    this.startTimeStamp_ \x3d null;\n\n    /**\n     * Timestamp of the end of the first tap.  Only updated for the first tap,\n     * since the end timestamp of the second tap is not needed to determine a\n     * double-tap.\n     * @private {?number}\n     */\n    this.endTimeStamp_ \x3d null;\n\n    /**\n     * The function to call on a completed double-tap.\n     * @private {function(!events.BrowserEvent, !Coordinate)}\n     */\n    this.doubleTapHandler_ \x3d doubleTapHandler;\n\n    /**\n     * The function to call on a completed single-tap.\n     * @private {?function(!events.BrowserEvent)}\n     */\n    this.singleTapHandler_ \x3d opt_singleTapHandler || null;\n\n    /**\n     * The setTimeout ID for detecting single clicks.\n     * @private {?number}\n     */\n    this.handleSingleClickTimeout_ \x3d null;\n  }\n\n  /**\n   * Call when a touchstart event is fired.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   */\n  onTouchStart(event) {\n    if (eventNumTouches(event) !\x3d 1) {\n      return;\n    }\n    const eventLocation \x3d eventTouchCoord(event, 0);\n    const currentEventTimeStamp \x3d eventTimeStamp(event);\n\n    scheduler.clearTimeout(this.handleSingleClickTimeout_);\n\n    // If a previous tap has already been recorded, compare:\n    //  - The start timestamp of this touch to the end of the previous tap.\n    //  - The distance between this touch and the position at the end of the\n    //    previous tap.\n    // If either is not true, discard the endTimeStamp of the first tap, and\n    // treat the new touch as a potential first tap.\n    if (!(this.location_ \x26\x26 this.endTimeStamp_ \x26\x26\n          currentEventTimeStamp - this.endTimeStamp_ \x3c\x3d TIME_SPACING_MAX \x26\x26\n          Coordinate.distance(eventLocation, this.location_) \x3c\x3d\n              DISTANCE_BETWEEN_TAPS_MAX)) {\n      this.endTimeStamp_ \x3d null;\n    }\n    this.location_ \x3d eventLocation;\n    this.startTimeStamp_ \x3d currentEventTimeStamp;\n  }\n\n\n  /**\n   * Call when a touchend event is fired.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   */\n  onTouchEnd(event) {\n    // Default is prevented here so that we can monitor for double-taps and\n    // ignore all single taps by default.\n    event.preventDefault();\n\n    // Only handle a single-tap ending.\n    if (eventNumTouches(event) !\x3d 0 || eventNumTouches(event, true) !\x3d 1) {\n      return;\n    }\n    const eventLocation \x3d eventTouchCoord(event, 0, true);\n    const currentEventTimeStamp \x3d eventTimeStamp(event);\n\n    // Compare the location and timestamp of the end of this touch to the\n    // location and timestamp of the start of the same touch.  This will\n    // include short taps, and reject drags and long taps.\n    if (this.location_ \x26\x26 this.startTimeStamp_ \x26\x26\n        currentEventTimeStamp - this.startTimeStamp_ \x3c\x3d TIME_TAP_MAX \x26\x26\n        Coordinate.distance(eventLocation, this.location_) \x3c\x3d\n            DISTANCE_TAP_MAX) {\n      if (this.endTimeStamp_) {\n        // First click was already completed.  This is the end of the second\n        // click.\n        this.doubleTapHandler_(event, eventLocation);\n        this.location_ \x3d null;\n        this.startTimeStamp_ \x3d null;\n        this.endTimeStamp_ \x3d null;\n      } else {\n        // This is the end of a first click.  Set a timeout so that we can fire\n        // a normal click event when there is no double click.\n        this.endTimeStamp_ \x3d currentEventTimeStamp;\n        this.startTimeStamp_ \x3d null;\n        this.handleSingleClickTimeout_ \x3d scheduler.setTimeout(\n            goog.bind(\n                this.handleSingleClick_, this, currentEventTimeStamp, event),\n            TIME_SPACING_MAX);\n      }\n    } else {\n      this.location_ \x3d null;\n      this.startTimeStamp_ \x3d null;\n      this.endTimeStamp_ \x3d null;\n    }\n  }\n\n\n  /**\n   * Call the registered single-tap function if it exists, checking that the\n   * timestamp from the touchend event is consistant, to avoid calling two\n   * clicks quickly.\n   * @param {number} endTimestamp The timestamp of the touchend event.\n   * @param {!events.BrowserEvent} event The touchend event.\n   * @private\n   */\n  handleSingleClick_(endTimestamp, event) {\n    this.handleSingleClickTimeout_ \x3d null;\n    if (!this.startTimeStamp_ \x26\x26 endTimestamp \x3d\x3d this.endTimeStamp_) {\n      if (this.singleTapHandler_ !\x3d null) {\n        this.singleTapHandler_(event);\n      }\n    }\n  }\n\n\n  /**\n   * Reset the state so that any pending taps or double-taps are ignored.\n   */\n  resetState() {\n    this.location_ \x3d null;\n    this.startTimeStamp_ \x3d null;\n    this.endTimeStamp_ \x3d null;\n    scheduler.clearTimeout(this.handleSingleClickTimeout_);\n  }\n}\n\nexports.DoubleTapHelper \x3d DoubleTapHelper;\nexports.eventNumTouches \x3d eventNumTouches;\nexports.eventTimeStamp \x3d eventTimeStamp;\nexports.eventTouchCoord \x3d eventTouchCoord;\nexports.pinchTransformationsEqual \x3d pinchTransformationsEqual;\nexports.setupTransformAnimation \x3d setupTransformAnimation;\n\n//# sourceURL\x3dhttps://qs/googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_utils.js\n");

$googDebugFname=undefined;
var $googDebugFname="googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_listener.js";
goog.loadModule("/**\n * @fileoverview Pinch to zoom feature. http://go/pinch-doc\n * @author ejharrington@google.com (Ellery Harrington)\n */\n\ngoog.module(\x27gws.images.viewer.pinch.PinchToZoomListener\x27);\ngoog.module.declareLegacyNamespace();\n\nconst Animated \x3d goog.require(\x27goog.fx.anim.Animated\x27);\nconst Animation \x3d goog.require(\x27search.animation.Animation\x27);\nconst AnimationDelay \x3d goog.require(\x27goog.async.AnimationDelay\x27);\nconst AnimationTimingParams \x3d goog.require(\x27search.animation.AnimationTimingParams\x27);\nconst Beacon \x3d goog.require(\x27gws.debug.telemetry.Beacon\x27);\nconst Coordinate \x3d goog.require(\x27goog.math.Coordinate\x27);\nconst Curves \x3d goog.require(\x27search.animation.Curves\x27);\nconst Disposable \x3d goog.require(\x27goog.Disposable\x27);\nconst ParGroup \x3d goog.require(\x27search.animation.ParGroup\x27);\nconst Promise \x3d goog.require(\x27goog.Promise\x27);\nconst QueryData \x3d goog.require(\x27goog.Uri.QueryData\x27);\nconst Size \x3d goog.require(\x27goog.math.Size\x27);\nconst UserAction \x3d goog.require(\x27proto.logs.UserAction\x27);\nconst anim \x3d goog.require(\x27goog.fx.anim\x27);\nconst array \x3d goog.require(\x27goog.array\x27);\nconst asserts \x3d goog.require(\x27goog.asserts\x27);\nconst classlist \x3d goog.require(\x27goog.dom.classlist\x27);\nconst config \x3d goog.require(\x27gws.images.viewer.config\x27);\nconst constants \x3d goog.require(\x27gws.images.viewer.constants\x27);\nconst dom \x3d goog.require(\x27goog.dom\x27);\nconst events \x3d goog.require(\x27goog.events\x27);\nconst historyState \x3d goog.require(\x27gws.historyState\x27);\nconst math \x3d goog.require(\x27goog.math\x27);\nconst nextTick \x3d goog.require(\x27goog.async.nextTick\x27);\nconst telemetry \x3d goog.require(\x27gws.debug.telemetry\x27);\nconst transform \x3d goog.require(\x27goog.style.transform\x27);\nconst utils \x3d goog.require(\x27gws.images.viewer.utils\x27);\nconst windowSize \x3d goog.require(\x27gws.images.windowSize\x27);\nconst {DoubleTapHelper, eventNumTouches, eventTimeStamp, eventTouchCoord, pinchTransformationsEqual, setupTransformAnimation} \x3d goog.require(\x27gws.images.viewer.pinch.util\x27);\nconst {DragState, Gesture, PinchState, PinchTransformation, SwipeDirection} \x3d goog.require(\x27gws.images.viewer.pinch.types\x27);\n\n/**\n * The smallest that an image can be viewed, relative to its initial size.\n * @const {number}\n */\nconst MIN_ZOOM_RATIO \x3d 1;\n\n/**\n * The smallest that an image can be viewed without an active gesture,\n * relative to its initial size.\n * @const {number}\n */\nconst MIN_ZOOM_RATIO_STEADY \x3d 1.25;\n\n/**\n * The largest that an image can be viewed, relative to its natural size.\n * @const {number}\n */\nconst MAX_ZOOM_RATIO_NATURAL \x3d 2;\n\n/**\n * The largest that an image can be viewed, relative to its original display\n * size. This value is superseded by MAX_ZOOM_RATIO_NATURAL depending on the\n * natural image size.\n * @const {number}\n */\nconst MAX_ZOOM_RATIO \x3d 2;\n\n/**\n * The default tranformation.\n * @const {!PinchTransformation}\n */\nconst IDENTITY_TRANSFORMATION \x3d {\n  scale: 1,\n  translation: new Coordinate(0, 0)\n};\n\n/**\n * The minimum ratio of directions (veritical \x26 horizontal) required to\n * trigger a swipe in either direction.\n * @const {number}\n */\nconst SWIPE_DIRECTION_RATIO \x3d 1.5;\n\n/**\n * The minimum size to zoom an image to when double-tapping, relative to its\n * initial size. It will be zoomed to 100% of its natrual size if that is\n * larger than DOUBLE_TAP_MIN_SCALE.\n * @const {number}\n */\nconst DOUBLE_TAP_MIN_SCALE \x3d 2;\n\n/**\n * The maximum size to zoom an image to when double-tapping, relative to its\n * initial size. It will be zoomed to 100% of its natrual size if that is\n * smaller than DOUBLE_TAP_MAX_SCALE.\n * @const {number}\n */\nconst DOUBLE_TAP_MAX_SCALE \x3d 6;\n\n/**\n * Speed (pixels/ms) for the scroll-to-top animation when starting a\n * pinch gesture in Flat UX when the image card is scrolled down.\n * @const {number}\n */\nconst SCROLL_TO_TOP_SPEED \x3d 0.5;\n\n/**\n * When panning an image horizontally to the edge of the screen, and\n * continuing to drag, the number of pixels before a swipe begins.\n * @const {number}\n */\nconst DISTANCE_OVERSWIPE_MID \x3d 100;\n\n/**\n * When panning an image horizontally starting at the edge of the screen,\n * the number of pixels before a swipe begins.\n * @const {number}\n */\nconst DISTANCE_OVERSWIPE_EDGE \x3d 50;\n\n/**\n * Scalar for zoom level to increase the resistance of swiping between\n * images when zoomed in.\n * @const {number}\n */\nconst OVERSWIPE_ZOOM_SCALAR \x3d 100;\n\n/**\n * Exponent for zoom level to increase the resistance of swiping between\n * images when zoomed in.\n * @const {number}\n */\nconst OVERSWIPE_ZOOM_SCALAR_EXP \x3d 0.7;\n\n/**\n * Number of pixels in an image to consider as a large image and use the\n * thumbnail during scaling animations.\n * @const {number}\n */\nconst LARGE_IMAGE_USE_THUMBNAIL_PIXELS \x3d 6000000;\n\n/**\n * Minimum length in px of a pinch at any time. Used to prevent\n * [artificially] small pinches from scaling too drastically.\n * @const {number}\n */\nconst MIN_PINCH_DIAMETER \x3d 50;\n\n/**\n * Muliplier for px/ms to pixels distance to travel.\n * @const {number}\n */\nconst MOMENTUM_SCALAR \x3d 150;\n\n/**\n * Minimum distance in pixels for a bounce-back animation.\n * @const {number}\n */\nconst MOMENTUM_BOUNCE_MIN_DISTANCE \x3d 20;\n\n/**\n * The maximum time in ms between a touchmove and touchend event to consider\n * for measuring velocity.\n * @const {number}\n */\nconst VELOCITY_MAX_TIME \x3d 100;\n\n/**\n * The exponent when backing off from a translation clamp.\n * @const {number}\n */\nconst CLAMP_BACKOFF_TRANSLATION \x3d 0.7;\n\n/**\n * The exponent when backing off from a translation clamp.\n * @const {number}\n */\nconst CLAMP_BACKOFF_SCALE \x3d 0.5;\n\n/**\n * Animation parameters for when clamping to a zoom level or translation\n * when the image has been zoomed or panned past its limits.\n * @const {!AnimationTimingParams}\n */\nconst CLAMP_ANIMATION_PARAMS \x3d {\n  delay: undefined,\n  duration: 100,\n  easing: Curves.FAST_OUT_SLOW_IN\n};\n\n/**\n * Animation parameters for when double-tapping to zoom in or zoom out.\n * @const {!AnimationTimingParams}\n */\nconst DOUBLE_TAP_IN_ANIMATION_PARAMS \x3d {\n  delay: undefined,\n  duration: 500,\n  easing: Curves.FAST_OUT_SLOW_IN\n};\n\n/**\n * Animation parameters for when double-tapping to zoom in or zoom out.\n * @const {!AnimationTimingParams}\n */\nconst DOUBLE_TAP_OUT_ANIMATION_PARAMS \x3d {\n  delay: undefined,\n  duration: 350,\n  easing: Curves.FAST_OUT_SLOW_IN\n};\n\n/**\n * Animation parameters for continuing to pan the image when a drag is\n * stopped but the finger was still moving.\n * @const {string}\n */\nconst MOMENTUM_ANIMATION_EASING \x3d Curves.LINEAR_OUT_SLOW_IN;\n\n/**\n * Easing param to bounce the image back into the frame after bouncing out.\n * @const {string}\n */\nconst MOMENTUM_BOUNCE_ANIMATION_EASING \x3d \x27cubic-bezier(.24,.13,.4,1.42)\x27;\n\n/**\n *\n * @enum {string}\n * @private\n */\nconst PinchLogGestures \x3d {\n  DOUBLE_TAP_IN: \x27di\x27,\n  DOUBLE_TAP_OUT: \x27do\x27,\n  SINGLE_TAP_OUT: \x27so\x27,\n  PINCH_IN: \x27pi\x27,\n  PINCH_OUT: \x27po\x27,\n};\n\n\n/**\n * Provides pinch-to-zoom functionality in the image-viewer.\n * @implements {Animated}\n */\nclass PinchToZoomListener extends Disposable {\n  /**\n   * @param {!Element} listenElement The element on which to apply touch\n   *     listeners.\n   */\n  constructor(listenElement) {\n    super();\n\n    /**\n     * Element that clicks are recorded on.\n     * @private {?Element}\n     */\n    this.clickElement_ \x3d null;\n\n    /**\n     * ImageCardView to be resized / repositioned. This is updated on each swipe\n     * and image-viewer open.\n     * @private {?gws.images.viewer.ImageCardView}\n     */\n    this.imageCardView_ \x3d null;\n\n    /**\n     * The number of touches currently on the image.\n     * @private {number}\n     */\n    this.numActiveTouches_ \x3d 0;\n\n    /**\n     * Array of listener keys for touch events.\n     * @private {!Array\x3c?events.Key\x3e}\n     */\n    this.listenerKeys_ \x3d [];\n\n    /**\n     * The cached size of the result card. Reset on each call to\n     * setImageCardView, and calculated/cached in getImageCardSize.\n     * @private {?Size}\n     */\n    this.imageCardSize_ \x3d null;\n\n    /**\n     * The cached displayed image. Updated on calls to getNaturalImageSize_.\n     * @private {?Element}\n     */\n    this.cachedDisplayedImage_ \x3d null;\n\n    /**\n     * The cached natural size of displayedImage_. Updated on calls to\n     * getNaturalImageSize_.\n     * @private {?Size}\n     */\n    this.cachedNaturalImageSize_ \x3d null;\n\n    /**\n     * Size and location of the pinch at the start of a two-finger pinch\n     * gesture.\n     * @private {?PinchState}\n     */\n    this.initialPinchState_ \x3d null;\n\n    /**\n     * Indicates whether a pinch has already ocurred.\n     * @private {boolean}\n     */\n    this.hasBeenZoomed_ \x3d false;\n\n    /**\n     * The current transformation of the image.\n     * @private {!PinchTransformation}\n     */\n    this.transformation_ \x3d IDENTITY_TRANSFORMATION;\n\n    /**\n     * The transformation when a pinch gesture started.\n     * @private {?PinchTransformation}\n     */\n    this.startGestureTransformation_ \x3d null;\n\n    /**\n     * The type of gesture that is currently active.\n     * @private {?Gesture}\n     */\n    this.activeGesture_ \x3d Gesture.NONE;\n\n    /**\n     * The location of the touch on the last 10 touchmove events from the\n     * current drag.\n     * @private {!Array\x3c!DragState\x3e}\n     */\n    this.lastDragStates_ \x3d [];\n\n    /**\n     * Displacement of a single-finger swipe gesture when a swipe action begins.\n     * @private {?Coordinate}\n     */\n    this.startSwipeDisplacement_ \x3d null;\n\n    /**\n     * Reported position of a swipe during a swipe gesture, or (0,0) when not in\n     * a swipe.\n     * @private {!Coordinate}\n     */\n    this.swipeDisplacement_ \x3d new Coordinate();\n\n    /**\n     * Whether currently registered for animation frames with\n     * anim.registerAnimation\n     * @private {boolean}\n     */\n    this.isRegisteredAnimation_ \x3d false;\n\n    /**\n     * Function to call on a single tap on the image.\n     * @private {?function(!Element, !Object\x3cstring, string\x3e, !Event)} handler\n     *     The function to handle a single tap on the image.\n     */\n    this.singleTapHandler_ \x3d null;\n\n    /**\n     * The current direction the image is being swiped, if any.\n     * @private {!SwipeDirection}\n     */\n    this.swipeDirection_ \x3d SwipeDirection.UNDETERMINED;\n\n    /**\n     * Whether to swap out the full image for a thumbnail during resizing.\n     * This is currently not enabled for any devices, but may be controlled\n     * per-device with a Mendel flag in the future based on performance metrics\n     * and Product decisions.\n     * @private {boolean}\n     */\n    this.useThumbnailForLargeImages_ \x3d false;\n\n    /**\n     * Whether animations (including bounce-back, momentum, and double-tap) are\n     * enabled.\n     * @private {boolean}\n     */\n    this.enableAnimations_ \x3d false;\n\n    /**\n     * Whether to use the Quantum Animation framework. If this is false and\n     * enableAnimations_ is true, uses CSS3 transition animations.\n     * @private {boolean}\n     */\n    this.useQuantumAnimations_ \x3d false;\n\n    if (config.proto.getPinchToZoomAnimation() \x3d\x3d \x27QUANTUM\x27) {\n      this.enableAnimations_ \x3d true;\n      this.useQuantumAnimations_ \x3d true;\n    } else if (config.proto.getPinchToZoomAnimation() \x3d\x3d \x27CSS3\x27) {\n      this.enableAnimations_ \x3d true;\n    }\n\n    /**\n     * Whether the PanelView is currently being animated with a Quantum or CSS3\n     * animation.\n     * @private {boolean}\n     */\n    this.panelViewAnimating_ \x3d false;\n\n    /**\n     * Animate a double-tap, even when animations are disbled.\n     * This is currently enabled for all devices, but may be controlled\n     * per-device with a Mendel flag in the future based on performance metrics\n     * and Product decisions.\n     * @private {boolean}\n     */\n    this.alwaysAnimateDoubleTap_ \x3d true;\n\n    /**\n     * Telemetry beacons for monitoring the smoothness of animations.\n     * @enum {!Beacon}\n     * @private\n     */\n    this.telemetryBeacons_ \x3d {\n      DOUBLE_TAP_IN: new Beacon(\x27images_carousel_pinch\x27, \x27double_tap_in\x27),\n      DOUBLE_TAP_OUT: new Beacon(\x27images_carousel_pinch\x27, \x27double_tap_out\x27),\n      CLAMP: new Beacon(\x27images_carousel_pinch\x27, \x27clamp\x27),\n      PINCH: new Beacon(\x27images_carousel_pinch\x27, \x27pinch\x27),\n      DRAG: new Beacon(\x27images_carousel_pinch\x27, \x27drag\x27),\n      SCROLL_TOP: new Beacon(\x27images_carousel_pinch\x27, \x27scroll_top\x27)\n    };\n\n    /**\n     * Resolver to provide the ved of the pinch-to-zoom logging element.\n     * @private {!goog.promise.Resolver\x3cstring\x3e}\n     */\n    this.vedResolver_ \x3d Promise.withResolver();\n\n    /**\n     * The maximum scale, relative to the original display size of the image\n     * that the image should be resampled to with ImageCardView.useScaledImage.\n     * New browsers have improved support for rendering large images at high\n     * quality when zoomed in.\n     * @private {number}\n     */\n    this.maxResampleScale_ \x3d config.proto.getPinchToZoomMaxResampleScale();\n\n    /**\n     * The double-tap helper. Detects single and double taps on the image and\n     * delegates them to the appropriate functions.\n     * @private {!DoubleTapHelper}\n     */\n    this.doubleTapHelper_ \x3d new DoubleTapHelper(\n        goog.bind(this.handleDoubleTap_, this),\n        goog.bind(this.handleSingleTap_, this));\n    this.registerDisposable(this.doubleTapHelper_);\n\n    this.addListeners_(listenElement);\n  }\n\n\n  /**\n   * Sets the ImageCardView that is being zoomed. This is called from\n   * PanelView.onUpdateCard when the ImageCardView is changed (swipes or\n   * image-viewer open), and when the state should be reset due to an\n   * image-viewer close or window resize event.\n   * @param {!gws.images.viewer.ImageCardView} imageCardView The new\n   *     image card view.\n   * @param {boolean} resetZoom Whether to reset the zoom on the image to 1x on\n   *     the current card. If imageCardView changed, the zoom will always be\n   *     reset.\n   */\n  setImageCardView(imageCardView, resetZoom) {\n    // Always reset the cached size of the card, because the image card size\n    // may have changed due to rotation.\n    this.imageCardSize_ \x3d null;\n    this.startGestureTransformation_ \x3d null;\n    this.activeGesture_ \x3d Gesture.NONE;\n    this.stopAnimation_();\n\n    if (this.imageCardView_ \x3d\x3d imageCardView \x26\x26 !resetZoom) {\n      return;\n    }\n\n    if (this.imageCardView_) {\n      const oldImageCardView \x3d this.imageCardView_;\n      // Reset the transformation of the previous ImageCardView.\n      const resetImageCardViewDelayed \x3d new AnimationDelay((timestamp) \x3d\x3e {\n        oldImageCardView.setPinchTransform(\n            IDENTITY_TRANSFORMATION.translation, IDENTITY_TRANSFORMATION.scale);\n        oldImageCardView.useScaledImage(1);\n      });\n      resetImageCardViewDelayed.start();\n    }\n\n    // Reset the transformation for the new ImageCardView.\n    this.transformation_ \x3d IDENTITY_TRANSFORMATION;\n    this.hasBeenZoomed_ \x3d false;\n    this.imageCardView_ \x3d imageCardView;\n    this.lastDragStates_ \x3d [];\n    this.clickElement_ \x3d this.imageCardView_.getImageContainerElement();\n    this.doubleTapHelper_.resetState();\n    this.vedResolver_.promise.cancel();\n    this.vedResolver_ \x3d Promise.withResolver();\n\n    this.updateImageCardView_();\n  }\n\n\n  /**\n   * Set the Visual Element Data to use for logging zooms.\n   * @param {string} ved The VED to use for logging.\n   * @return {!Promise\x3cstring\x3e} The promise that was resolved.\n   */\n  setVed(ved) {\n    if (ved) {\n      this.vedResolver_.resolve(ved);\n    }\n    return this.vedResolver_.promise;\n  }\n\n\n  /**\n   * Gets the EI for logging zoom interactions.\n   * @return {?string}\n   * @private\n   */\n  getEi_() {\n    return google.getEI(dom.getRequiredElement(constants.BACKGROUND_ID));\n  }\n\n\n  /**\n   * Gets and caches the size of the image card. If either dimension is 0, it is\n   * returned but not cached.\n   * @return {!Size} The size of the image card.\n   * @private\n   */\n  getImageCardSize_() {\n    let imageCardSize \x3d this.imageCardSize_;\n    if (imageCardSize \x3d\x3d null) {\n      imageCardSize \x3d asserts.assert(this.imageCardView_).getResultCardSize();\n      if (imageCardSize.getShortest() !\x3d 0) {\n        this.imageCardSize_ \x3d imageCardSize;\n      }\n    }\n    return imageCardSize;\n  }\n\n\n  /**\n   * Gets and caches the natural size of the displayed (hotlink / thumbnail)\n   * image.\n   * @return {?Size} The natural size of the displayed image.\n   * @private\n   */\n  getNaturalImageSize_() {\n    const displayedImage \x3d\n        this.imageCardView_ \x26\x26 this.imageCardView_.getDisplayedImage();\n    if (!displayedImage) {\n      return null;\n    }\n    if (this.cachedNaturalImageSize_ \x26\x26\n        displayedImage \x3d\x3d this.cachedDisplayedImage_) {\n      return this.cachedNaturalImageSize_;\n    }\n    this.cachedDisplayedImage_ \x3d displayedImage;\n    if (!displayedImage.naturalWidth || !displayedImage.naturalHeight) {\n      this.cachedNaturalImageSize_ \x3d null;\n      return this.getScaledImageSize_(1);\n    }\n    this.cachedNaturalImageSize_ \x3d\n        new Size(displayedImage.naturalWidth, displayedImage.naturalHeight);\n    return this.cachedNaturalImageSize_;\n  }\n\n\n  /**\n   * Get the display size of the image when scaled.\n   * @param {number\x3d} opt_scale If provided, the scale at which the size should\n   *     be calculated. Defaults to the current scale size.\n   * @return {?Size} The displayed size of the image after scaling.\n   * @private\n   */\n  getScaledImageSize_(opt_scale) {\n    const displayedImageSize \x3d\n        this.imageCardView_ \x26\x26 this.imageCardView_.getDisplayedImageSize();\n    if (displayedImageSize \x3d\x3d null) {\n      return null;\n    }\n    const scale \x3d opt_scale ? opt_scale : this.transformation_.scale;\n    if (scale \x3d\x3d 1) {\n      return displayedImageSize;\n    }\n    return displayedImageSize.clone().scale(scale);\n  }\n\n\n  /**\n   * Handles touchstart event, determining whether the gesture is a pinch or\n   * drag.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   * @private\n   */\n  handleTouchStart_(event) {\n    // If animating, don\x27t handle a new touch until after the animation is\n    // complete. handleTouchStart_ will be called from handleTouchMove_.\n    if (this.panelViewAnimating_ ||\n        this.ignoreEventsOn_(asserts.assertElement(event.target))) {\n      return;\n    }\n    this.numActiveTouches_ \x3d eventNumTouches(event);\n    if (this.hasBeenZoomed_ || this.isElementInClickElement_(event.target)) {\n      this.doubleTapHelper_.onTouchStart(event);\n    }\n\n    this.maybeEndGesture_();\n    this.maybeStartGesture_(event);\n  }\n\n  /**\n   * Handles a touch event when the user is removing one or more fingers from\n   * the gesture.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   * @private\n   */\n  handleTouchEnd_(event) {\n    if (this.panelViewAnimating_ ||\n        this.ignoreEventsOn_(asserts.assertElement(event.target))) {\n      return;\n    }\n    const previousNumActiveTouches \x3d this.numActiveTouches_;\n    this.numActiveTouches_ \x3d eventNumTouches(event);\n    // 3+ touches were present and now only 1-2 are. A new pinch/drag begins,\n    // so use handleTouchStart to handle it as a new touch.\n    if (this.numActiveTouches_ \x3e\x3d 1 \x26\x26 this.numActiveTouches_ \x3c\x3d 2 \x26\x26\n        previousNumActiveTouches \x3e 2) {\n      this.maybeStartGesture_(event);\n      return;\n    }\n    if (this.isElementInClickElement_(event.target) ||\n        this.transformation_.scale \x3e 1) {\n      this.doubleTapHelper_.onTouchEnd(event);\n    }\n\n    // Add the current position and timestamp for calculating velocity.\n    this.lastDragStates_.push({\n      position: eventTouchCoord(event, 0, true),\n      timeStamp: eventTimeStamp(event)\n    });\n    this.maybeEndGesture_();\n    // Allows pinches to becomes zooms, and vice versa.\n    this.maybeStartGesture_(event);\n\n    this.swipeDirection_ \x3d SwipeDirection.UNDETERMINED;\n    this.lastDragStates_ \x3d [];\n  }\n\n\n  /**\n   * Handles a movement of one or more touches on the image.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   * @private\n   */\n  handleTouchMove_(event) {\n    if (this.panelViewAnimating_) {\n      return;\n    }\n    const numEventTouches \x3d eventNumTouches(event);\n    if (numEventTouches \x3e this.numActiveTouches_) {\n      // Touchstart events are ignored during animations. If there are more\n      // touches that previously recorded, handle them as new touches.\n      this.handleTouchStart_(event);\n    }\n\n    if (this.numActiveTouches_ \x3d\x3d 2 \x26\x26 this.initialPinchState_ \x26\x26\n        this.startGestureTransformation_ \x26\x26 numEventTouches \x3d\x3d 2) {\n      const currentPinchState \x3d this.calculatePinchState_(event);\n      this.transformation_ \x3d this.getPinchTransformation_(currentPinchState);\n    } else {\n      if (this.transformation_.scale \x3e 1) {\n        this.maybeDrag_(event);\n      }\n    }\n  }\n\n\n  /**\n   * Handle a double-tap gesture on the image. Toggles between the original\n   * display size and the double-tap scale (usually calculated at 100% of the\n   * image size).\n   * @param {!events.BrowserEvent} event The event causing the double-tap.\n   * @param {!Coordinate} position The location of the double-tap,\n   *     relative to the image-viewer.\n   * @private\n   */\n  handleDoubleTap_(event, position) {\n    if (!this.hasBeenZoomed_) {\n      this.imageCardView_.forceRenderHotlinkedImage();\n      this.hasBeenZoomed_ \x3d true;\n    }\n    let animationParams;\n    let telemetryBeacon;\n    let positionData;\n    if (this.transformation_.scale \x3d\x3d IDENTITY_TRANSFORMATION.scale) {\n      const imageSize \x3d this.getScaledImageSize_(1);\n      if (!imageSize) {\n        return;\n      }\n      const boundingBox \x3d this.imageCardView_.getImageBoundingBox();\n      const imageCenter \x3d new Coordinate(\n          boundingBox.left + imageSize.width / 2,\n          boundingBox.top + imageSize.height / 2 -\n              utils.getPageVerticalScroll());\n      const scale \x3d math.clamp(\n          this.getNaturalRatio_(), DOUBLE_TAP_MIN_SCALE, DOUBLE_TAP_MAX_SCALE);\n      let translation \x3d\n          Coordinate.difference(imageCenter, position).scale(scale);\n      // For a double tap zooming in, log the location of the tap relative to\n      // the image.\n      const logTapPosition \x3d\n          this.windowPositionToImagePercent_(position, IDENTITY_TRANSFORMATION);\n      positionData \x3d\n          [PinchLogGestures.DOUBLE_TAP_IN, logTapPosition.x, logTapPosition.y];\n      // Consider the change in available screen space between the original\n      // image bounding box to the full space in the image card.\n      const verticalImageCenter \x3d windowSize.getHeight() / 2;\n      const fullHeightImageCenter \x3d\n          new Coordinate(imageCenter.x, verticalImageCenter);\n      const positionChange \x3d\n          Coordinate.difference(fullHeightImageCenter, imageCenter);\n      translation \x3d Coordinate.sum(translation, positionChange);\n      this.transformation_ \x3d {scale: scale, translation: translation};\n      this.transformation_ \x3d\n          this.strictClampTransformation_(this.transformation_);\n      animationParams \x3d DOUBLE_TAP_IN_ANIMATION_PARAMS;\n      telemetryBeacon \x3d this.telemetryBeacons_.DOUBLE_TAP_IN;\n    } else {\n      // For a double tap zooming out, log the current position in the viewport.\n      positionData \x3d\n          this.getViewportPositionData_(PinchLogGestures.DOUBLE_TAP_OUT);\n      this.transformation_ \x3d IDENTITY_TRANSFORMATION;\n      animationParams \x3d DOUBLE_TAP_OUT_ANIMATION_PARAMS;\n      telemetryBeacon \x3d this.telemetryBeacons_.DOUBLE_TAP_OUT;\n    }\n    this.logZoom(UserAction.DOUBLE_TAP, positionData);\n    this.maybeScrollToTop(() \x3d\x3e {\n      this.zoomForDoubleTap_(animationParams, telemetryBeacon);\n    });\n  }\n\n\n  /**\n   * Zoom to this.transformation_.scale, following a double-tap action.\n   * @param {!AnimationTimingParams} animationParams\n   * Configuration for animation of the zoom.\n   * @param {!Beacon} telemetryBeacon The beacon to fire\n   *     during this animation.\n   * @private\n   */\n  zoomForDoubleTap_(animationParams, telemetryBeacon) {\n    if (this.enableAnimations_ || this.alwaysAnimateDoubleTap_) {\n      this.useLowResolutionImage_();\n      this.updateImageCardView_(animationParams, telemetryBeacon, true);\n      if (this.transformation_.scale \x3e 1) {\n        // If zooming in, bring image on top of fixed header immediately.\n        this.imageCardView_.updateElementZIndexes();\n      }\n    } else {\n      this.updateImageDisplayResolution_();\n      this.updateImageCardView_();\n    }\n  }\n\n\n  /**\n   * Handle a tap on the image. When zoomed in Flat UX, zooms back to 1X.\n   * Otherwise, singleTapHandler is called.\n   * @param {!events.BrowserEvent} event The touchend event that indicated\n   *     a single tap.\n   * @private\n   */\n  handleSingleTap_(event) {\n    if (this.transformation_.scale \x3e 1) {\n      // For a single tap zooming out, log the current position in the viewport.\n      const positionData \x3d\n          this.getViewportPositionData_(PinchLogGestures.SINGLE_TAP_OUT);\n      // When zoomed in, animate back to 1x.\n      this.transformation_ \x3d IDENTITY_TRANSFORMATION;\n      if (this.enableAnimations_ || this.alwaysAnimateDoubleTap_) {\n        this.useLowResolutionImage_();\n        this.updateImageCardView_(\n            DOUBLE_TAP_OUT_ANIMATION_PARAMS,\n            this.telemetryBeacons_.DOUBLE_TAP_OUT, true);\n      } else {\n        this.updateImageDisplayResolution_();\n        this.updateImageCardView_();\n      }\n      this.logZoom(UserAction.TAP, positionData);\n    } else if (this.singleTapHandler_ !\x3d null) {\n      this.singleTapHandler_(\n          asserts.assertElement(event.target), {},\n          asserts.assert(event.getBrowserEvent()));\n    }\n  }\n\n\n  /**\n   * Determine if a gesture (pinch or drag) needs to start, and start it.\n   * @param {!events.BrowserEvent} event The touchstart or touchend event\n   *     that indicated a gesture was starting.\n   * @private\n   */\n  maybeStartGesture_(event) {\n    switch (this.numActiveTouches_) {\n      case 2:\n        if (!this.isElementInClickElement_(event.target)) {\n          // Don\x27t allow a pinch outside the image container.\n          return;\n        }\n\n        const pinchState \x3d this.calculatePinchState_(event);\n        asserts.assert(pinchState);\n        if (this.activeGesture_ !\x3d Gesture.PINCH \x26\x26\n            this.swipeDisplacement_.x \x3d\x3d 0 \x26\x26 this.swipeDisplacement_.y \x3d\x3d 0) {\n          // Start a new pinch.\n          if (!this.hasBeenZoomed_) {\n            this.imageCardView_.forceRenderHotlinkedImage();\n            this.hasBeenZoomed_ \x3d true;\n          }\n          this.initialPinchState_ \x3d pinchState;\n          this.useLowResolutionImage_();\n          this.startGestureTransformation_ \x3d this.transformation_;\n          this.activeGesture_ \x3d Gesture.PINCH;\n          telemetry.beginInteraction(this.telemetryBeacons_.PINCH);\n          this.startAnimation_();\n          this.maybeScrollToTop(goog.bind(\n              this.imageCardView_.updateElementZIndexes, this.imageCardView_,\n              true));\n        }\n        break;\n\n      case 1:\n        if (this.activeGesture_ \x3d\x3d Gesture.NONE \x26\x26\n            this.transformation_.scale \x3e 1) {\n          // Start a new drag.\n          this.lastDragStates_ \x3d [];\n          this.startGestureTransformation_ \x3d this.transformation_;\n          this.activeGesture_ \x3d Gesture.DRAG;\n          telemetry.beginInteraction(this.telemetryBeacons_.DRAG);\n          this.startAnimation_();\n          this.maybeDrag_(event);\n        }\n        break;\n    }\n  }\n\n\n  /**\n   * If Flat UX is enabled and the image card is scrolled vertially, scrolls\n   * back to the top and calls the callback function after the animation is\n   * complete. Otherwise, callback is called immediately.\n   * @param {function()} callback The callback function to call on completion.\n   */\n  maybeScrollToTop(callback) {\n    const cardElement \x3d this.imageCardView_.getCardElement();\n    const scrollTop \x3d utils.getPageVerticalScroll();\n    if (scrollTop \x3e 0) {\n      const timingParams \x3d {\n        delay: undefined,\n        duration: scrollTop / SCROLL_TO_TOP_SPEED,\n        easing: Curves.FAST_OUT_SLOW_IN\n      };\n      utils.setPageVerticalScroll(0);\n      const initialCardElementHeight \x3d cardElement.style.height;\n      cardElement.style.height \x3d\n          (parseInt(initialCardElementHeight, 10) + scrollTop) + \x27px\x27;\n      // If the card is scrolled vertically, scroll back the top before\n      // allowing pinching/resizing.\n      this.panelViewAnimating_ \x3d true;\n\n      const cardElementTransform \x3d transform.getTranslation(cardElement);\n      new Animation(cardElement, timingParams)\n          .translateFrom(cardElementTransform.x, -scrollTop, 0)\n          .translateTo(cardElementTransform.x, 0, 0)\n          .play()\n          .then(() \x3d\x3e {\n            cardElement.style.height \x3d initialCardElementHeight;\n            this.panelViewAnimating_ \x3d false;\n            callback();\n          });\n      return;\n    }\n    // We did not need to scroll to top; execute the callback immediately.\n    callback();\n  }\n\n\n  /**\n   * Determine if a gesture (pinch or drag) needs to end, and end it.\n   * @private\n   */\n  maybeEndGesture_() {\n    if (this.activeGesture_ \x3d\x3d Gesture.PINCH \x26\x26 this.numActiveTouches_ !\x3d 2) {\n      // End a pinch gesture.\n      this.transformation_ \x3d this.clampTransformation_(\n          this.transformation_, this.startGestureTransformation_.scale);\n      let positionData;\n      if (this.transformation_.scale \x3e this.startGestureTransformation_.scale) {\n        const pt1 \x3d this.windowPositionToImagePercent_(\n            this.initialPinchState_.pt1, this.startGestureTransformation_);\n        const pt2 \x3d this.windowPositionToImagePercent_(\n            this.initialPinchState_.pt2, this.startGestureTransformation_);\n        // For a pinch that zooms in, log the location of both points of the\n        // initial pinch,\n        positionData \x3d [PinchLogGestures.PINCH_IN, pt1.x, pt1.y, pt2.x, pt2.y];\n      } else {\n        // For a pinch that zooms out, log the the current position in the\n        // viewport.\n        positionData \x3d this.getViewportPositionData_(\n            PinchLogGestures.PINCH_OUT, this.startGestureTransformation_);\n      }\n      this.initialPinchState_ \x3d null;\n      this.stopAnimation_();\n      this.startGestureTransformation_ \x3d null;\n      this.activeGesture_ \x3d Gesture.NONE;\n      telemetry.endInteraction(this.telemetryBeacons_.PINCH);\n      const strictClampedTransformation \x3d\n          this.strictClampTransformation_(this.transformation_);\n      if (!pinchTransformationsEqual(\n              this.transformation_, strictClampedTransformation)) {\n        this.transformation_ \x3d strictClampedTransformation;\n        this.updateImageCardView_(\n            CLAMP_ANIMATION_PARAMS, this.telemetryBeacons_.CLAMP);\n      } else {\n        this.updateImageDisplayResolution_();\n      }\n      this.logZoom(UserAction.PINCH, positionData);\n    }\n\n    if (this.activeGesture_ \x3d\x3d Gesture.DRAG \x26\x26 this.numActiveTouches_ !\x3d 1) {\n      // End a drag gesture.\n      this.stopAnimation_();\n      this.startGestureTransformation_ \x3d null;\n      this.activeGesture_ \x3d Gesture.NONE;\n      telemetry.endInteraction(this.telemetryBeacons_.DRAG);\n      if (this.enableAnimations_ \x26\x26 this.numActiveTouches_ \x3d\x3d 0) {\n        this.playDragReleaseAnimation_();\n      } else {\n        this.transformation_ \x3d this.clampTransformation_(this.transformation_);\n      }\n    }\n  }\n\n\n  /**\n   * Calculates the instantaneous PinchState (diameter, center, and time stamp)\n   * when there are two active touches on the image. Returns null when there are\n   * not exactly two touches on the image.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   * @return {!PinchState} The PinchState,\n   *     based on the distance and location of the two active touches.\n   * @private\n   */\n  calculatePinchState_(event) {\n    const pt1 \x3d eventTouchCoord(event, 0);\n    const pt2 \x3d eventTouchCoord(event, 1);\n    // Impose a minimum pinch size so that a pinch starting at diameter near 0\n    // does not make the scaling too drastic.\n    return {\n      pt1: pt1,\n      pt2: pt2,\n      diameter: Math.max(Coordinate.distance(pt1, pt2), MIN_PINCH_DIAMETER),\n      center: new Coordinate((pt2.x + pt1.x) / 2, (pt2.y + pt1.y) / 2),\n      timeStamp: event.getBrowserEvent().timeStamp\n    };\n  }\n\n\n  /**\n   * During animations, use a lower display resolution of the image to avoid\n   * jank, slow redrawing, and browser crashes. For large images, this may\n   * replace the hotlinked image with the thumbnail for use during scaling, for\n   * performance reasons. Otherwise, use the image at 1x scale.\n   * @private\n   */\n  useLowResolutionImage_() {\n    const naturalImageSize \x3d this.getNaturalImageSize_();\n    if (this.useThumbnailForLargeImages_ \x26\x26 naturalImageSize \x26\x26\n        naturalImageSize.area() \x3e LARGE_IMAGE_USE_THUMBNAIL_PIXELS) {\n      // Very large images may use thumbnail during scaling gestures for\n      // performance reasons.\n      this.updateImageDisplayResolution_(0);\n    } else {\n      this.updateImageDisplayResolution_(1);\n    }\n  }\n\n\n  /**\n   * Handle a single-finger touchmove event on the image. Pan the image without\n   * scaling it.\n   * @param {!events.BrowserEvent} event The event wrapping a TouchEvent.\n   * @private\n   */\n  maybeDrag_(event) {\n    if (this.numActiveTouches_ !\x3d 1) {\n      return;\n    }\n    event.stopPropagation();\n    const currentDragState \x3d {\n      position: eventTouchCoord(event, 0),\n      timeStamp: eventTimeStamp(event)\n    };\n    const lastDragState \x3d this.lastDragStates_[this.lastDragStates_.length - 1];\n    this.lastDragStates_.push(currentDragState);\n    if (this.lastDragStates_.length \x3e 10) {\n      this.lastDragStates_.shift();\n    }\n    if (lastDragState) {\n      this.transformation_ \x3d {\n        scale: this.transformation_.scale,\n        translation: Coordinate.sum(\n            this.transformation_.translation,\n            Coordinate.difference(\n                currentDragState.position, lastDragState.position))\n      };\n    }\n  }\n\n\n  /**\n   * Renders the \x3cimg\x3e in ImageCardView at a higher resolution, scaled from the\n   * original display size. Limits the rendering resolution based on\n   * maxResampleScale_.\n   * @param {number\x3d} opt_scale The scale with which to render the image, where\n   *     1 is the original display size. Defaults to the current scale.\n   * @private\n   */\n  updateImageDisplayResolution_(opt_scale) {\n    const scale \x3d math.clamp(\n        opt_scale ? opt_scale : Math.floor(this.transformation_.scale), 1,\n        this.maxResampleScale_);\n    this.imageCardView_.useScaledImage(scale);\n  }\n\n\n  /**\n   * Determine the current transformation based on the initial and current pinch\n   * states. This must only be called when a pinch gesture is active and\n   * this.initialPinchState_ and this.startGestureTransformation_ are set.\n   * @param {!PinchState} currentPinchState The\n   *     current state of the pinch.\n   * @return {!PinchTransformation}\n   * @private\n   */\n  getPinchTransformation_(currentPinchState) {\n    const scale \x3d currentPinchState.diameter / this.initialPinchState_.diameter;\n    return {\n      translation: Coordinate.sum(\n          this.startGestureTransformation_.translation,\n          Coordinate.difference(\n              currentPinchState.center, this.initialPinchState_.center)),\n      scale: this.startGestureTransformation_.scale * scale\n    };\n  }\n\n\n  /**\n   * Gets the ratio of the image\x27s natural full-resolution size to the original\n   * display size of the image.\n   * @return {number}\n   * @private\n   */\n  getNaturalRatio_() {\n    const naturalSize \x3d this.getNaturalImageSize_();\n    const displayedSize \x3d this.getScaledImageSize_(1);\n    if (!naturalSize || !displayedSize) {\n      return 1;\n    }\n    return naturalSize.width / displayedSize.width;\n  }\n\n\n  /**\n   * Limit the scale to between acceptable values, depending on the minimum and\n   * maximum zoom sizes, optionally using a backoff function.\n   * @param {number} scale The desired scale.\n   * @param {boolean\x3d} opt_strict Whether to force a strict clamp between the\n   *     bounds. If false, uses a backoff function for values outside the\n   *     normal range.\n   * @return {number} The clamped scale.\n   * @private\n   */\n  clampScale_(scale, opt_strict) {\n    var clampFunction \x3d opt_strict ?\n        math.clamp :\n        goog.bind(this.clampBackoff_, this, CLAMP_BACKOFF_SCALE);\n    const naturalRatio \x3d this.getNaturalRatio_();\n    if (opt_strict \x26\x26 scale \x3c MIN_ZOOM_RATIO_STEADY) {\n      return IDENTITY_TRANSFORMATION.scale;\n    }\n    return clampFunction(\n        scale, MIN_ZOOM_RATIO,\n        Math.max(MAX_ZOOM_RATIO, MAX_ZOOM_RATIO_NATURAL * naturalRatio));\n  }\n\n\n  /**\n   * Limit transformation (scale and translation) to acceptable values based on\n   * the image and container sizes, optionally using a backoff function when\n   * animations are enabled. When animations are enabled, this gives a\n   * resistance effect. e.g. When scaling below 1x, the image is resized but not\n   * to the full extent that the pinch gesture initially indicates.\n   * @param {PinchTransformation} transform The\n   *     transformation to clamp.\n   * @param {number\x3d} opt_scaleTranslationFrom The scale to use as a reference\n   *     when calculating the translation. Defaults to transform.scale.\n   * @param {boolean\x3d} opt_strict Whether to force a strict clamp between the\n   *     bounds. If false, uses a backoff function for values outside the\n   *     normal range. For convenience, use strictClampTransformation_ instead\n   *     of using opt_strict.\n   * @return {PinchTransformation} The clamped\n   *     transformation.\n   * @private\n   */\n  clampTransformation_(transform, opt_scaleTranslationFrom, opt_strict) {\n    const strict \x3d !this.enableAnimations_ || opt_strict;\n    const clampedScale \x3d this.clampScale_(transform.scale, strict);\n    const imageScaledSize \x3d this.getScaledImageSize_(clampedScale);\n    if (imageScaledSize \x3d\x3d null) {\n      return transform;\n    }\n    const overflow \x3d\n        this.calculateOverflow_(imageScaledSize, this.getImageCardSize_());\n\n    const scaleTranslationFrom \x3d\n        opt_scaleTranslationFrom ? opt_scaleTranslationFrom : transform.scale;\n    const scaleClampFactor \x3d clampedScale / scaleTranslationFrom;\n\n    var clampFunction \x3d strict ?\n        math.clamp :\n        goog.bind(this.clampBackoff_, this, CLAMP_BACKOFF_TRANSLATION);\n    const clampedTransformation \x3d {\n      translation: new Coordinate(\n          clampFunction(\n              transform.translation.x * scaleClampFactor, -overflow.width,\n              overflow.width),\n          clampFunction(\n              transform.translation.y * scaleClampFactor, -overflow.height,\n              overflow.height)),\n      scale: clampedScale\n    };\n    return clampedTransformation;\n  }\n\n\n  /**\n   * Convenience method for strict clamping. Clamps within the bounds without\n   * using a backoff function. Strict clamping is used when animating back to\n   * limits when the image has been scaled / dragged beyond the limits. E.g.,\n   * When the image has been scaled below 1x, a strict clamp is used to\n   * determine the destination transformation to animate towards.\n   * @param {PinchTransformation} transform The\n   *     transformation to clamp.\n   * @param {number\x3d} opt_scaleTranslationFrom The scale to use as a reference\n   *     when calculating the translation. Defaults to transform.scale.\n   * @return {PinchTransformation} The clamped\n   *     transformation.\n   * @private\n   */\n  strictClampTransformation_(transform, opt_scaleTranslationFrom) {\n    return this.clampTransformation_(transform, opt_scaleTranslationFrom, true);\n  }\n\n\n  /**\n   * Backoff for clamping functions. When past the min / max value, performs a\n   * Math.pow on the overage. When n \x3e max, the return value will still be\n   * \x3e max, but less than n.\n   * @param {number} exponent The factor to backoff by. Should be in (0, 1).\n   *     e.g. 0.5 would indicate a square root backoff.\n   * @param {number} n The number to clamp.\n   * @param {number} min The minimum value.\n   * @param {number} max The maximum value.\n   * @return {number} The result of the backoff calculation.\n   * @private\n   */\n  clampBackoff_(exponent, n, min, max) {\n    if (n \x3c min) {\n      return min - Math.pow(min - n + 1, exponent) + 1;\n    } else if (n \x3e max) {\n      return max + Math.pow(n - max + 1, exponent) - 1;\n    } else {\n      return n;\n    }\n  }\n\n\n  /**\n   * @param {number} distance The distance in pixels that the image has been\n   *     panned on the x-axis.\n   * @param {number} overflow The distance in pixels that the image has been\n   *     panned on the x-axis.\n   * @return {boolean} Whether the image has been panned beyond its normal\n   *     bounds on the x-axis enough to trigger a swipe.\n   * @private\n   */\n  isOverswiped_(distance, overflow) {\n    const isInitiallyAtEdge \x3d\n        (this.activeGesture_ \x3d\x3d Gesture.DRAG \x26\x26\n         Math.abs(this.startGestureTransformation_.translation.x) \x3e\x3d\n             overflow - 1);\n    const overswipeDistanceRequired \x3d\n        (isInitiallyAtEdge ? DISTANCE_OVERSWIPE_EDGE : DISTANCE_OVERSWIPE_MID) +\n        Math.pow(\n            this.transformation_.scale * OVERSWIPE_ZOOM_SCALAR,\n            OVERSWIPE_ZOOM_SCALAR_EXP);\n    return distance \x3e overswipeDistanceRequired;\n  }\n\n\n  /**\n   * Calculate the overflow of the image: The distance that the image hangs off\n   * the edge of the screen when centered. If the image does not extend beyond\n   * the container (for example, when not zoomed), the overflow is 0.\n   *\n   * Example: If an image when zoomed is 20px larger than the container on the\n   * x-axis (and not larger in the y-axis), the overflow is calculated as\n   * {width: 10, height: 0} because each horizontal edge is 10px over.\n   * @param {!Size} imageScaledSize The size of the image, after\n   *     scaling.\n   * @param {!Size} containerSize The size of the container.\n   * @return {!Size} The overflow of the image.\n   * @private\n   */\n  calculateOverflow_(imageScaledSize, containerSize) {\n    return new Size(\n        Math.max(0, (imageScaledSize.width - containerSize.width) / 2),\n        Math.max(0, (imageScaledSize.height - containerSize.height) / 2));\n  }\n\n\n  /**\n   * Calculates the swiping distance based on the current size and position of\n   * the image, and the user\x27s panning action. Called from SwipeHandler.\n   * @param {!Coordinate} swipeDisplacement The displacement of a\n   *     single-finger drag gesture.\n   * @return {!Coordinate} The displacement that should be observed by\n   *     the SwipeHandler for transitioning between images or triggering\n   *     features, considering the scale and position of the image.\n   */\n  swipeDisplacementCallback(swipeDisplacement) {\n    if (this.numActiveTouches_ \x3e 1) {\n      // No swiping when more than one touch is active.\n      return IDENTITY_TRANSFORMATION.translation;\n    }\n    const imageScaledSize \x3d this.getScaledImageSize_();\n    if (this.transformation_.scale \x3c\x3d 1 || imageScaledSize \x3d\x3d null) {\n      this.swipeDisplacement_ \x3d swipeDisplacement;\n      return swipeDisplacement;\n    }\n\n    const overflow \x3d\n        this.calculateOverflow_(imageScaledSize, this.getImageCardSize_());\n\n    // The offset beyond the edge of the screen that the image has been panned.\n    const swipeOffset \x3d new Coordinate(\n        this.calculateSwipeOffset_(\n            overflow.width, this.transformation_.translation.x),\n        this.calculateSwipeOffset_(\n            overflow.height, this.transformation_.translation.y));\n\n    // Swiping is not currently active. Check if it should become active.\n    if (this.swipeDirection_ \x3d\x3d SwipeDirection.UNDETERMINED) {\n      const isSwipingHorizontally \x3d Math.abs(swipeDisplacement.x) \x3e\n          Math.abs(swipeDisplacement.y) * SWIPE_DIRECTION_RATIO;\n      if (this.isOverswiped_(Math.abs(swipeOffset.x), overflow.width) \x26\x26\n          isSwipingHorizontally \x26\x26 swipeOffset.x !\x3d 0) {\n        // Swiping horizontally when zoomed in requires that the image is\n        // overswiped.\n        this.swipeDirection_ \x3d\n            swipeOffset.x \x3e 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n        this.startSwipeDisplacement_ \x3d swipeOffset;\n      }\n    }\n\n    if (this.swipeDirection_ \x3d\x3d SwipeDirection.LEFT ||\n        this.swipeDirection_ \x3d\x3d SwipeDirection.RIGHT) {\n      // Swiping horizontally. Report a swipe displacement based on the current\n      // swipeOffset and startSwipeDisplacement_\n      let swipeDisplacementX \x3d swipeOffset.x - this.startSwipeDisplacement_.x;\n\n      // If the offset has returned to 0, or the swipe is going in the opposite\n      // direction as it started in, end the swipe and report (0,0).\n      if (swipeOffset.x \x3d\x3d 0 ||\n          (this.swipeDirection_ \x3d\x3d SwipeDirection.LEFT \x26\x26\n           swipeDisplacementX \x3c 0) ||\n          (this.swipeDirection_ \x3d\x3d SwipeDirection.RIGHT \x26\x26\n           swipeDisplacementX \x3e 0)) {\n        this.swipeDirection_ \x3d SwipeDirection.UNDETERMINED;\n        swipeDisplacementX \x3d 0;\n      }\n\n      this.swipeDisplacement_ \x3d new Coordinate(swipeDisplacementX, 0);\n    } else if (\n        this.swipeDirection_ \x3d\x3d SwipeDirection.UP ||\n        this.swipeDirection_ \x3d\x3d SwipeDirection.DOWN) {\n      // Swiping vertically. Report a Y swipe displacement based on the current\n      // swipeOffset and startSwipeDisplacement_\n      let swipeDisplacementY \x3d swipeOffset.y - this.startSwipeDisplacement_.y;\n\n      // If the offset has returned to 0, end the swipe and report (0,0).\n      if (swipeOffset.y \x3d\x3d 0) {\n        this.swipeDirection_ \x3d SwipeDirection.UNDETERMINED;\n        swipeDisplacementY \x3d 0;\n      }\n\n      this.swipeDisplacement_ \x3d new Coordinate(0, swipeDisplacementY);\n    } else {\n      // Swipe direction is UNDETERMINED.\n      this.swipeDisplacement_ \x3d IDENTITY_TRANSFORMATION.translation;\n    }\n    return this.swipeDisplacement_;\n  }\n\n\n  /**\n   * Determine the offset that the image has been dragged beyond its normal\n   * bounds in one axis. This value will be used to determine if user is\n   * intending to swipe.\n   * @param {number} overflow The width of the image that overhangs one side of\n   *     the screen, in either the x or y axis.\n   * @param {number} displacement The displacement of the image in either the x\n   *     or y axis.\n   * @return {number} The offset in pixels that the user has swiped in one axis.\n   *     If the image has not scrolled off the edge of the screen, 0 is\n   *     returned.\n   * @private\n   */\n  calculateSwipeOffset_(overflow, displacement) {\n    if (displacement \x3e 0) {\n      return Math.max(0, displacement - overflow);\n    }\n    return Math.min(0, displacement + overflow);\n  }\n\n\n  /**\n   * Update the translation and scale of the image card view, optionally\n   * animating. An animation is performed when opt_animateTimingParams is\n   * provided, and either this.enableAnimations_ or opt_forceAnimation is true.\n   * @param {!AnimationTimingParams\x3d} opt_animateTimingParams\n   * If non- null, params to use for a Quantum / CSS3 animation to the\n   * destination transformation. If null, no animation will be executed.\n   * @param {!Beacon\x3d} opt_telemetryBeacon The telemetry\n   *     beacon activate while an animation is playing.\n   * @param {boolean\x3d} opt_forceAnimation Always animate, even when\n   *     this.enableAnimations_ is false.\n   * @private\n   */\n  updateImageCardView_(\n      opt_animateTimingParams, opt_telemetryBeacon, opt_forceAnimation) {\n    const animate \x3d opt_animateTimingParams !\x3d null \x26\x26\n        (this.enableAnimations_ || opt_forceAnimation);\n    if (!animate) {\n      // Not a Quantum / CSS animation. Just request one frame.\n      this.startAnimation_(true);\n      this.imageCardView_.updateElementZIndexes();\n      return;\n    }\n\n    const clampedTransformation \x3d this.getCurrentClampedTransform_(true);\n    // When animating, update the state of the ImageCardView without setting\n    // the transform on the element.\n    this.imageCardView_.setPinchTransform(\n        clampedTransformation.translation, clampedTransformation.scale,\n        true /* opt_noSetTransform */);\n    this.panelViewAnimating_ \x3d true;\n    const onComplete \x3d () \x3d\x3e {\n      if (opt_telemetryBeacon) {\n        telemetry.endInteraction(opt_telemetryBeacon);\n      }\n      this.animationComplete_();\n    };\n\n    if (this.useQuantumAnimations_) {\n      const imageAnimation \x3d\n          new Animation(\n              this.imageCardView_.getImageContainerElement(),\n              asserts.assert(opt_animateTimingParams))\n              .scaleTo(\n                  clampedTransformation.scale, clampedTransformation.scale, 1)\n              .translateTo(\n                  clampedTransformation.translation.x,\n                  clampedTransformation.translation.y, 0);\n      let metadataFadingAnimation;\n      const metadataFadingElement \x3d\n          this.imageCardView_.getMetadataFadingElement();\n      if (metadataFadingElement) {\n        metadataFadingAnimation \x3d\n            new Animation(\n                asserts.assertElement(metadataFadingElement),\n                asserts.assert(opt_animateTimingParams))\n                .opacityTo(\n                    this.imageCardView_.getMetadataFadingElementOpacity());\n      }\n      new ParGroup([imageAnimation, metadataFadingAnimation])\n          .play()\n          .then(onComplete);\n    } else {\n      setupTransformAnimation(\n          this.imageCardView_.getImageContainerElement(),\n          asserts.assert(opt_animateTimingParams))\n          .then(onComplete);\n      nextTick(goog.bind(\n          this.imageCardView_.setPinchTransform, this.imageCardView_,\n          clampedTransformation.translation, clampedTransformation.scale));\n    }\n    if (opt_telemetryBeacon) {\n      telemetry.beginInteraction(opt_telemetryBeacon);\n    }\n  }\n\n\n  /**\n   * After an animation completes, indicate that the animation is no longer\n   * playing and update the display resolution.\n   * @private\n   */\n  animationComplete_() {\n    this.panelViewAnimating_ \x3d false;\n    this.updateImageDisplayResolution_();\n    this.imageCardView_.updateElementZIndexes();\n  }\n\n\n  /**\n   * Gets the current transformation clamped in the bounds allowed.\n   * @param {boolean\x3d} opt_strict Whether to get the strict clamped\n   *     transformation.\n   * @return {!PinchTransformation}\n   * @private\n   */\n  getCurrentClampedTransform_(opt_strict) {\n    const scale \x3d this.activeGesture_ \x3d\x3d Gesture.PINCH ?\n        this.startGestureTransformation_.scale :\n        this.transformation_.scale;\n    return this.clampTransformation_(this.transformation_, scale, opt_strict);\n  }\n\n\n  /**\n   * Immediately update the transform of the ImageCardView\x27s DOM. This should\n   * only be called from within onAnimationFrame.\n   * @private\n   */\n  updatePinchTransform_() {\n    const clampedTransformation \x3d this.getCurrentClampedTransform_();\n    if (this.imageCardView_ !\x3d null) {\n      this.imageCardView_.setPinchTransform(\n          clampedTransformation.translation, clampedTransformation.scale);\n    }\n  }\n\n\n  /**\n   * Calculates the velocity (px/ms) of an active drag.\n   * @return {?Coordinate} The instantaneous velocity in (px/ms), or\n   *     null if no drag is ending.\n   * @private\n   */\n  calculateVelocity_() {\n    if (this.lastDragStates_.length \x3c 2) {\n      return null;\n    }\n    const currentDragState \x3d\n        this.lastDragStates_[this.lastDragStates_.length - 1];\n    // Find the oldest DragState on record within 100ms to reduce jitter.\n    const previousDragState \x3d\n        array.find(this.lastDragStates_, function(dragState) {\n          const timeDifference \x3d\n              currentDragState.timeStamp - dragState.timeStamp;\n          return timeDifference \x3e 0 \x26\x26 timeDifference \x3c VELOCITY_MAX_TIME;\n        }, this);\n    if (!previousDragState) {\n      return null;\n    }\n    // Instantaneous velocity (px/ms)\n    return Coordinate\n        .difference(currentDragState.position, previousDragState.position)\n        .scale(1 / (currentDragState.timeStamp - previousDragState.timeStamp));\n  }\n\n\n  /**\n   * When a drag is released, check if there is a velocity at the time of\n   * release. If so, initiate an animation to continue the motion. If not, check\n   * if the transformation needs to be strictly clamped and animate to that\n   * position. This function should only be called when enableAnimations_ is\n   * true.\n   * @private\n   */\n  playDragReleaseAnimation_() {\n    // Instantaneous velocity (px/ms)\n    const velocity \x3d this.calculateVelocity_();\n    let velocityMagnitude \x3d 0;\n    if (velocity !\x3d null) {\n      velocityMagnitude \x3d Coordinate.magnitude(velocity);\n    }\n    if (velocityMagnitude \x3e 0.1) {\n      this.transformation_ \x3d {\n        scale: this.transformation_.scale,\n        translation: Coordinate.sum(\n            this.transformation_.translation, velocity.scale(MOMENTUM_SCALAR))\n      };\n      const looseClampedTransformation \x3d\n          this.clampTransformation_(this.transformation_);\n      const strictClampedTransformation \x3d\n          this.strictClampTransformation_(this.transformation_);\n\n      /** @type {?AnimationTimingParams} */\n      let animationParams \x3d null;\n      if (this.swipeDirection_ \x3d\x3d SwipeDirection.UNDETERMINED) {\n        const strictOffset \x3d Coordinate.difference(\n            looseClampedTransformation.translation,\n            strictClampedTransformation.translation);\n\n        // Check if the destination of the image after applying momentum would\n        // be out of bounds and that the direction out-of-bounds matches the\n        // primary direction that the image is being moved.\n        if (Coordinate.magnitude(strictOffset) \x3e MOMENTUM_BOUNCE_MIN_DISTANCE \x26\x26\n            (Math.abs(strictOffset.x) \x3e Math.abs(strictOffset.y) \x26\x26\n                 Math.abs(velocity.x) \x3e Math.abs(velocity.y) ||\n             Math.abs(strictOffset.y) \x3e Math.abs(strictOffset.x) \x26\x26\n                 Math.abs(velocity.y) \x3e Math.abs(velocity.x))) {\n          // Use an animation with bounce-back.\n          animationParams \x3d {\n            delay: undefined,\n            duration: math.clamp(velocityMagnitude * 1000, 100, 400),\n            easing: MOMENTUM_BOUNCE_ANIMATION_EASING\n          };\n        } else {\n          animationParams \x3d {\n            delay: undefined,\n            duration: math.clamp(velocityMagnitude * 800, 100, 350),\n            easing: MOMENTUM_ANIMATION_EASING\n          };\n        }\n      }\n      this.transformation_ \x3d strictClampedTransformation;\n      this.updateImageCardView_(\n          animationParams ? animationParams : undefined,\n          this.telemetryBeacons_.CLAMP);\n    } else {\n      // No momentum. Check if the tranformation needs to be clamped.\n      const strictClampedTransformation \x3d\n          this.strictClampTransformation_(this.transformation_);\n      if (!pinchTransformationsEqual(\n              strictClampedTransformation, this.transformation_)) {\n        this.transformation_ \x3d strictClampedTransformation;\n        this.updateImageCardView_(CLAMP_ANIMATION_PARAMS);\n      }\n    }\n  }\n\n\n  /**\n   * Start recieving animation frame events if not already.\n   * @param {boolean\x3d} opt_singleFrame Whether to request just one frame.\n   * @private\n   */\n  startAnimation_(opt_singleFrame) {\n    if (opt_singleFrame) {\n      const animationDelayed \x3d new AnimationDelay((timestamp) \x3d\x3e {\n        this.onAnimationFrame(timestamp);\n      });\n      animationDelayed.start();\n    } else if (!this.isRegisteredAnimation_) {\n      this.isRegisteredAnimation_ \x3d true;\n      anim.registerAnimation(this);\n    }\n  }\n\n\n  /**\n   * Stop recieving animation frame events if currently recieving them. One\n   * additional frame will be processed after this call.\n   * @private\n   */\n  stopAnimation_() {\n    this.isRegisteredAnimation_ \x3d false;\n  }\n\n\n  /** @override */\n  onAnimationFrame(now) {\n    if (!this.isRegisteredAnimation_) {\n      anim.unregisterAnimation(this);\n    }\n    this.updatePinchTransform_();\n  }\n\n\n  /**\n   * @param {function(!Element, !Object\x3cstring, string\x3e, !Event)} handler The\n   *     function to handle a single tap on the image.\n   */\n  setClickHandler(handler) {\n    this.singleTapHandler_ \x3d handler;\n  }\n\n\n  /**\n   * Determines whether the element is contained in, or is the same as, the\n   * clickElement and the current gesture should be considered in that element.\n   * @param {?Node} element The element to check.\n   * @return {boolean} Whether the element is inside or equal to clickElement.\n   * @private\n   */\n  isElementInClickElement_(element) {\n    return !!this.clickElement_ \x26\x26 dom.contains(this.clickElement_, element);\n  }\n\n\n  /**\n   * Listen for touch events on the given element.\n   * @param {!Element} listenElement The element to bind all events.\n   * @private\n   */\n  addListeners_(listenElement) {\n    this.listenerKeys_.push(events.listen(\n        listenElement, events.EventType.TOUCHSTART,\n        goog.bind(this.handleTouchStart_, this)));\n    this.listenerKeys_.push(events.listen(\n        listenElement, events.EventType.TOUCHMOVE,\n        goog.bind(this.handleTouchMove_, this)));\n    this.listenerKeys_.push(events.listen(\n        listenElement, events.EventType.TOUCHEND,\n        goog.bind(this.handleTouchEnd_, this)));\n  }\n\n\n  /**\n   * Log a completed zoom. Param \x27scl\x27 is a floating point number representing\n   * the new zoom-level after the interaction, and is the size of the image\n   * relative to its original display size. scl\x3d1 indicates the original display\n   * size; scl\x3d2 indicates 2x the original display width and height.\n   * @param {number} uact User action from UserAction.\n   * @param {!Array\x3cstring|number\x3e} positionData Data concerning the location of\n   *     interaction.\n   */\n  logZoom(uact, positionData) {\n    const scale \x3d this.transformation_.scale.toPrecision(3);\n    const tbnid \x3d this.imageCardView_.getActiveImageId();\n    const qParam \x3d historyState.getParam(\x27q\x27);\n    const ei \x3d this.getEi_();\n    this.vedResolver_.promise.then((ved) \x3d\x3e {\n      const params \x3d\n          new QueryData()\n              .add(\x27ei\x27, ei)\n              .add(\x27q\x27, qParam)\n              .add(\x27scl\x27, scale)\n              .add(\x27tbnid\x27, tbnid)\n              .add(\x27uact\x27, uact)\n              .add(\x27ved\x27, ved)\n              .add(\x27z\x27, positionData.join(\x27_\x27));  // See go/pinch-logging.\n      google.log(\x27ipz_zoom\x27, params.toString());\n    }, goog.nullFunction);\n  }\n\n\n  /**\n   * Gets position data concerning the location of the image in the viewport.\n   * See go/pinch-logging for details.\n   * @param {string} interationType The string to include in the position data\n   *     to describe the type of interation being reported.\n   * @param {!PinchTransformation\x3d} opt_transformation\n   *     A transformation to use for measurement. Defaults to\n   *     this.transformation_.\n   * @return {!Array\x3cstring|number\x3e} Position data to be passed to logZoom_.\n   * @private\n   */\n  getViewportPositionData_(interationType, opt_transformation) {\n    const transformation \x3d opt_transformation || this.transformation_;\n    const pt1 \x3d this.windowPositionToImagePercent_(\n        new Coordinate(0, 0), transformation);\n    const pt2 \x3d this.windowPositionToImagePercent_(\n        new Coordinate(windowSize.getWidth(), windowSize.getHeight()),\n        transformation);\n\n    return [interationType, pt1.x, pt1.y, pt2.x, pt2.y];\n  }\n\n\n  /**\n   * Converts from window coordinates in pixels to integer percentages relative\n   * to the image in the position described by transformation.\n   * @param {!Coordinate} screenPosition Window position in pixels.\n   * @param {!PinchTransformation} transformation\n   *     Transformation to apply to the image for calulcating position relative\n   *     to the image.\n   * @return {!Coordinate}\n   * @private\n   */\n  windowPositionToImagePercent_(screenPosition, transformation) {\n    const boundingBox \x3d this.imageCardView_.getImageBoundingBox();\n    const imageSize \x3d this.getScaledImageSize_(transformation.scale);\n    return new Coordinate(\n        Math.round(\n            (imageSize.width / 2 - transformation.translation.x -\n             boundingBox.width / 2 - boundingBox.left + screenPosition.x) /\n            imageSize.width * 100),\n        Math.round(\n            (imageSize.height / 2 - transformation.translation.y -\n             boundingBox.height / 2 - boundingBox.top + screenPosition.y) /\n            imageSize.height * 100));\n  }\n\n  /**\n   * @param {!Element} element Element that recieved the event\n   * @return {boolean} True to ignore touch events\n   * @private\n   */\n  ignoreEventsOn_(element) {\n    // Image overlay for the mobile reporting workflow.\n    return (classlist.contains(element, \x27feedback-result\x27) \x26\x26\n            !!dom.getAncestorByClass(\n                element, constants.MAIN_IMAGE_CONTAINER)) ||\n        !!dom.getAncestor(element, (elem) \x3d\x3e {\n          if (!dom.isElement(elem)) {\n            return false;\n          }\n          elem \x3d asserts.assertElement(elem);\n          // Play button for personal videos.\n          return classlist.contains(elem, constants.PLAY_BUTTON_CLASS) ||\n              // Anything inside the action bar overlay\n              classlist.contains(elem, constants.ACTION_BAR_OVERLAY_CLASS);\n        }, true /* opt_includeNode */);\n  }\n\n\n  /** @override */\n  disposeInternal() {\n    super.disposeInternal();\n    array.forEach(this.listenerKeys_, function(listenerKey) {\n      events.unlistenByKey(listenerKey);\n    });\n    this.imageCardView_ \x3d null;\n    this.cachedDisplayedImage_ \x3d null;\n    this.singleTapHandler_ \x3d null;\n  }\n}\n\n\nexports \x3d PinchToZoomListener;\n\n//# sourceURL\x3dhttps://qs/googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_listener.js\n");

$googDebugFname=undefined;
var $googDebugFname="googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_controller.js";
goog.loadModule("/**\n * @fileoverview Pinch to zoom feature. http://go/pinch-doc\n * @author ejharrington@google.com (Ellery Harrington)\n */\n\ngoog.module(\x27gws.images.viewer.pinch.Controller\x27);\ngoog.module.declareLegacyNamespace();\n\nconst Disposable \x3d goog.require(\x27goog.Disposable\x27);\nconst PinchToZoomListener \x3d goog.require(\x27gws.images.viewer.pinch.PinchToZoomListener\x27);\nconst Promise \x3d goog.require(\x27goog.Promise\x27);\nconst constants \x3d goog.require(\x27gws.images.viewer.constants\x27);\nconst dom \x3d goog.require(\x27goog.dom\x27);\n\n\n/**\n * Jscontroller for Pinch-to-Zoom. Creates a PinchToZoomListener and registers\n * it with the active PanelView.\n */\nconst Controller \x3d goog.defineClass(Disposable, {\n  constructor: function() {\n    Controller.base(this, \x27constructor\x27);\n\n    /**\n     * The listener for Pinch-to-Zoom functionality.\n     * @private {?PinchToZoomListener}\n     */\n    this.pinchToZoomListener_ \x3d null;\n  },\n\n  /**\n   * Initialize Pinch-to-Zoom for the provided PanelView. Called from\n   * PanelView\x27s constructor.\n   * @param {gws.images.viewer.PanelView} panelView The panelView to\n   * initialize for Pinch-to-Zoom.\n   */\n  initialize: function(panelView) {\n    if (this.pinchToZoomListener_ !\x3d null) {\n      this.pinchToZoomListener_.dispose();\n    }\n    const background \x3d dom.getElement(constants.BACKGROUND_ID);\n    if (background \x3d\x3d null) {\n      return;\n    }\n\n    this.pinchToZoomListener_ \x3d new PinchToZoomListener(background);\n    this.registerDisposable(this.pinchToZoomListener_);\n\n    panelView.addOnUpdateCardListener(goog.bind(\n        this.pinchToZoomListener_.setImageCardView, this.pinchToZoomListener_));\n    panelView.setSwipeDisplacementCallback(goog.bind(\n        this.pinchToZoomListener_.swipeDisplacementCallback,\n        this.pinchToZoomListener_));\n    this.pinchToZoomListener_.setClickHandler(\n        goog.bind(panelView.handleCardClick, panelView));\n  },\n\n\n  /**\n   * Wrapper for PinchToZoomListener.setVed to allow external components to set\n   * the pinch-to-zoom ved.\n   * @param {string} ved The updated ved.\n   * @return {?Promise\x3cstring\x3e} The promise that was resolved, or null if the\n   *     listener has not been initialized.\n   */\n  setVed: function(ved) {\n    if (this.pinchToZoomListener_) {\n      return this.pinchToZoomListener_.setVed(ved);\n    } else {\n      return null;\n    }\n  }\n});\n\nexports \x3d Controller;\n\n//# sourceURL\x3dhttps://qs/googledata/html/templates/gws/head/xjs/plugins/images/viewer/pinch_to_zoom_controller.js\n");

$googDebugFname=undefined;
var $googDebugFname="jar:file:java/com/google/gws/common/jslayout/images/pinch_to_zoom_html_pinto.jslayout.js.zip!/gws.common.jslayout.images.pinch_to_zoom.PinchToZoomTemplate.jslayout.js";
eval("// -*- mode: js -*-\n/**\n * @fileoverview Generated code, do not modify.\n * Generated from java/com/google/gws/common/jslayout/images/pinch_to_zoom.html.\n * Generated by template/prototemplate/jslayout/codegeneration/api_js.tpl.\n *\n * @suppress {uselessCode|transitionalSuspiciousCodeWarnings|extraRequire|missingRequire}\n */\n\n// Below are flags and original source file used to generate this\n// file. Used by ModuleSetsServer to provide edit/refresh for\n// jslayout_js() rules. Omitted in codegeneration/example; cf.\n// example_update.sh.\n/* [[BUILD_ARGS]]\nsource_file: \x22java/com/google/gws/common/jslayout/images/pinch_to_zoom.html\x22\nbuilder_arg: \x22java/com/google/gws/common/jslayout/images/pinch_to_zoom.html\x22\nbuilder_arg: \x22--artifacts\x22\nbuilder_arg: \x22w,desc_pool,xmb\x22\nbuilder_arg: \x22--gendir\x22\nbuilder_arg: \x22blaze-out/k8-opt/genfiles\x22\nbuilder_arg: \x22--template_root\x22\nbuilder_arg: \x22,blaze-out/k8-opt/bin\x22\nbuilder_arg: \x22--output_directory\x22\nbuilder_arg: \x22blaze-out/k8-opt/genfiles\x22\nbuilder_arg: \x22--xtb_basedir\x22\nbuilder_arg: \x22googledata/transconsole/xtb\x22\nbuilder_arg: \x22--mode\x22\nbuilder_arg: \x22single\x22\nbuilder_arg: \x22--stderrthreshold\x3d1\x22\nbuilder_arg: \x22--xmb_output_file_suffix\x22\nbuilder_arg: \x22.gws\x22\nbuilder_arg: \x22--strict_mode\x22\nbuilder_arg: \x22--use_attribute_whitelist\x22\nbuilder_arg: \x22--jscontroller_type\x3dreactive\x22\nbuilder_arg: \x22--parser_config\x22\nbuilder_arg: \x22blaze-out/k8-opt/genfiles/googledata/gws/jslayout/parser_config_safe_sanitized\x22\nbuilder_arg: \x22--tc_project\x3dgws\x22\nbuilder_arg: \x22--expflags_files\x3dblaze-out/k8-opt/genfiles/googledata/gws/experiments/mendel/gws/features/images/viewer_mendel_jslayout_interface.expflags\x22\nbuilder_arg: \x22--source_base_dirs\x22\nbuilder_arg: \x22blaze-out/k8-opt/genfiles,blaze-out/k8-opt/genfiles\x22\nrenderer_arg: \x22blaze-out/host/bin/template/prototemplate/jslayout/renderer\x22\nrenderer_arg: \x22--input_root\x3dblaze-out/k8-opt/genfiles,blaze-out/k8-opt/genfiles\x22\nrenderer_arg: \x22--input\x3dblaze-out/k8-opt/genfiles/java/com/google/gws/common/jslayout/images/pinch_to_zoom.html.w\x22\nrenderer_arg: \x22--js_output\x3dblaze-out/k8-opt/bin/java/com/google/gws/common/jslayout/images/pinch_to_zoom_html_pinto.jslayout.js.zip\x22\nrenderer_arg: \x22--js_wrapper\x22\nrenderer_arg: \x22--entrypoint\x3dtrue\x22\nrenderer_arg: \x22--generate_only_browserside_template\x22\nrenderer_arg: \x22--generate_controller_only\x22\nrenderer_arg: \x22--generate_separate_files_per_template\x22\nrenderer_arg: \x22--use_apps_jspb\x22\nrenderer_arg: \x22--use_reactive\x22\n[[/BUILD_ARGS]] */\n\ngoog.provide(\x27gws.common.jslayout.images.pinch_to_zoom.PinchToZoomTemplate\x27);\n\n\n// Forward declaration for JSPB and IDL classes/interfaces.\ngoog.forwardDeclare(\x27jslayout.TemplatePool\x27);\n\n// Reactive and IDL jscontroller classes,\n// IDL classes with static method invocations, enum types,\n// imports used by certain expression language features,\n// reactive and IDL jscontroller JSPB protos,\n// Soy templates used via soyTemplate() built-in.\ngoog.require(\x27gws.images.viewer.pinch.Controller\x27);\ngoog.require(\x27jslayout.EvalContext\x27);\ngoog.require(\x27jslayout.reactive.framework\x27);\n\n\n\n\n// Controller registration code generated by:\n// template/prototemplate/jslayout/javascript/controller_registration_js.tpl\n\n\n/**\n * @param {!jslayout.reactive.ControllerPool} pool\n */\ngws.common.jslayout.images.pinch_to_zoom.PinchToZoomTemplate.registerController \x3d function(pool) {\n  pool.registerController(\n      \x27t-HKUuVFxOI0c\x27, gws.images.viewer.pinch.Controller, null,\n      null,\n      function(tempObj, model, dom) {\n        gws.images.viewer.pinch.Controller.call(\n            /** @type {gws.images.viewer.pinch.Controller} */(tempObj));\n      },\n      \x27gws.images.viewer.pinch.Controller\x27);\n};\n\n\n// Auto controller/template registration for reactive templates generated by:\n// template/prototemplate/jslayout/javascript/controller_registration_js.tpl\njslayout.reactive.framework.registerController(\n    gws.common.jslayout.images.pinch_to_zoom.PinchToZoomTemplate.registerController);\n\n\n//# sourceURL\x3dhttps://qs/jar:file:java/com/google/gws/common/jslayout/images/pinch_to_zoom_html_pinto.jslayout.js.zip!/gws.common.jslayout.images.pinch_to_zoom.PinchToZoomTemplate.jslayout.js\n");

$googDebugFname=undefined;


/** @suppress {missingRequire} */ /** @suppress {missingRequire} */
goog.module.ModuleManager.getInstance().setLoaded('pz');
/** @suppress {missingRequire} */
goog.module.ModuleManager.getInstance().afterLoadModuleCode('pz');

}catch(e){_DumpException(e)}
/* _GlobalSuffix_ */
// Google Inc.
